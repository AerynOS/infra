{% extends "skel.html.jinja" %}
{% block body %}
    <div id="queueOptions" class="queue-options">
        <div>
            <span id="graphCount">{{ nodes|length }} tasks</span>
            <span>|</span>
            <input type="text" id="queueFindNode" class="queue-options__search" placeholder="Search Queue..." value="">
        </div>
        <label><input id="queueShowDeps" type="checkbox" checked />Deps</label>
        <label><input id="queueShowRevdeps" type="checkbox" checked />Revdeps</label>
    </div>
    <div id="queueGraph" class="queue-graph">
    </div>
{% endblock %}

{% block javascript %}
    <script type="module">
        import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

        const borderColor = getComputedStyle(document.documentElement).getPropertyValue('--link-hover-color');

        const links = JSON.parse('{{ links|safe }}');
        const nodes = JSON.parse('{{ nodes|safe }}');

        const rect = queueGraph.getBoundingClientRect();
        const width = rect.width;
        const height = window.innerHeight - rect.y;
        const nodeRadius = 5;
        const hMargin = 50;
        const maxDepth = Math.max(...nodes.map(a => a.depth));
        const xPerDepth = (width - hMargin * 2) / maxDepth;

        const rainbow = d3.interpolateHslLong("red", "violet");

        const simulation = d3.forceSimulation(nodes)
            // No force applied, only for connecting lines
            .force("link", d3.forceLink(links).id(d => d.id).strength(0))
            .force("charge", d3.forceManyBody().strength(-1))
            .force("collide", d3.forceCollide(d => nodeRadius))
            .force("position", d3.forceX(d => d.depth * xPerDepth).strength(_ => 1.0))
            .alphaDecay(0.1)
            .on("tick", ticked);

        const svg = d3.create("svg")
            .attr("viewBox", [-hMargin, -height / 2, width, height])
            .attr("style", "")
            .attr("cursor", "crosshair");

        const g = svg.append("g");

        const link = g.append("g")
            .attr("stroke", "#999")
            .attr("stroke-opacity", 0.3)
            .selectAll()
            .data(links)
            .join("line")
            .attr("stroke-width", 0.5);
        const node = g.append("g")
            .attr("stroke", borderColor)
            .attr("stroke-width", 1.5)
            .selectAll()
            .data(nodes)
            .join("circle")
            .attr("r", nodeRadius)
            .attr("fill", d => rainbow(d.depth / maxDepth));

        let selected;
        let showDeps = queueShowDeps.checked;
        let showRevdeps = queueShowRevdeps.checked;

        const selectNode = (targetId) => {
            const targetNode = nodes.find(n => n.id == targetId);
            const deps = showDeps ? targetNode.dependencies : [];
            const revdeps = showRevdeps ? nodes.filter(n => n.dependencies.includes(targetId)).map(n => n.id) : [];
            const visibleNodes = [
                targetId,
                ...deps,
                ...revdeps,
            ];
            const showLink = (link) => {
                return deps.includes(link.source.id) && deps.includes(link.target.id)
                    || revdeps.includes(link.source.id) && revdeps.includes(link.target.id)
                    || showDeps && link.source.id == targetId
                    || showRevdeps && link.target.id == targetId;
            };
            node.attr("fill", n => n.id == targetId ? rainbow(0.5) : deps.includes(n.id) ? rainbow(0) : rainbow(1));
            node.attr("visibility", n => visibleNodes.includes(n.id) ? "visible" : "hidden");
            link.attr("visibility", l => showLink(l) ? "visible" : "hidden");
            selected = targetId;
            queueFindNode.value = targetNode.name;
        };

        const deselectNode = () => {
            node.attr("fill", n => rainbow(n.depth / maxDepth));
            node.attr("visibility", "visible");
            link.attr("visibility", "visible");
            selected = undefined;
            queueFindNode.value = "";
        };

        const onNodeClick = (event) => {
            event.stopPropagation();

            const targetId = event.target.__data__.id;

            if (selected === targetId) {
                deselectNode();
            } else {
                selectNode(targetId);
            }
        };

        const onCanvasClick = () => {
            if(selected) {
                deselectNode();
            }
        };

        queueShowDeps.addEventListener('click', (e) => {
            showDeps = e.target.checked;
            if(selected) {
                const prev = selected;
                deselectNode();
                selectNode(prev);
            }
        });
        queueShowRevdeps.addEventListener('click', (e) => {
            showRevdeps = e.target.checked;
            if(selected) {
                const prev = selected;
                deselectNode();
                selectNode(prev);
            }
        });
        queueFindNode.addEventListener('keyup', (e) => {
            if(event.key == "Enter") {
                if(e.target.value !== "") {
                    const lookup = e.target.value.trim().toLowerCase();
                    const node = nodes.find(n => n.name.toLowerCase() == lookup);
                    if(node) {
                        selectNode(node.id);
                    }
                } else {
                    deselectNode();
                }
            }
        });

        node
          .on("click", onNodeClick)
          .append("title")
          .text(d => `${d.depth} - ${d.package}`);

        svg.on("click", onCanvasClick);

        function ticked() {
          link
              .attr("x1", d => d.source.x)
              .attr("y1", d => d.source.y)
              .attr("x2", d => d.target.x)
              .attr("y2", d => d.target.y);

          node
              .attr("cx", d => d.x)
              .attr("cy", d => d.y);
        }

        const zoom = d3.zoom().on("zoom", e => {
            g.attr("transform", e.transform);
        });

        queueGraph.append(
            svg
              .call(zoom)
              .call(zoom.transform, d3.zoomIdentity)
              .node()
        );
    </script>
{% endblock %}
